<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Go Functional Programming Kata</title>

		<link rel="apple-touch-icon" sizes="180x180" href="./dist/theme/img/apple-touch-icon.png">
		<link rel="icon" type="image/png" sizes="32x32" href="./dist/theme/img/favicon-32x32.png">
		<link rel="icon" type="image/png" sizes="16x16" href="./dist/theme/img/favicon-16x16.png">
		<link rel="manifest" href="./site.webmanifest">

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/pandora.css">
		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/night-owl.css">


	</head>
	<body>
		<div class="reveal">
			<div class="slides">


				<section data-background-image="./dist/theme/img/main.webp">
					<h1 style="color: #f8f9fb; margin-top: 120px">Functional Programming in Go</h1>
					<img class="r-stretch" alt="Functional Kata Gopher" src="./dist/theme/img/fp_kata_gopher.png"/>
					<div class="left-align" style="color: #f8f9fb; padding-left: 4px; background-color:rgba(0, 0, 0, 0.5);">Matthias Koch | <span class="footnote-text">Delivery Hero</span></div>
					<div class="footnote-text left-align" style="color: #f8f9fb; padding-left: 4px; background-color:rgba(0, 0, 0, 0.5);">functional style since 2013 - Skala Java Kotlin Haskell-(EM) <b style="font-weight:bold; font-size: 1.6em; color: #f8f9fb; ">Go</b> Dart</div>
				</section>


				<section data-background-image="./dist/theme/img/background.png" >
					<h2>Ready To Relieve Your High School Algebra Nightmare?</h2>
					<br/>
					\[
					T(x) = \sum_{n=0}^\infty \frac{f^{(n)}(a)}{n!}(x-a)^n
					\]
					<br/>
					<span class="fragment">
						<pre>Haskell Example:<code class="language-haskell" data-trim data-noescape>
							taylor :: (Double -> Double) -> (Double -> Double) -> Double -> Double -> Double taylor f f' a x = f a + f' a * (x - a)
						</code></pre>
					</span>
				</section>


				<section data-background-image="./dist/theme/img/background.png" >
					<h2>Don't Worry, Gophers</h2>
					<br/>
					<p>It was a joke!</p>
					<br/>
					<p>If we were algebra professionals, we wouldn't write Go code! ðŸ˜‰</p>
					<br/>
					<p>We like things <strong>simple</strong>, <strong>easy</strong>, and <strong>small</strong>.</p>
				</section>


				<section data-background-image="./dist/theme/img/background.png" >
					<h2>What This Presentation Is About</h2>
					<p>This presentation is <strong>not</strong> about the mathematics in functional programming.</p>
					<div style="display: flex; align-items: center; gap: 20px;">
						<div>
							<p class="left-align">Our brain (our natural language model) has at least <br/>a 6-year advantage in training natural language over math.</p>
							<p class="fragment left-align">It's about how functional programming principles can help you write <strong>better code</strong>:</p>
							<ul class="fragment left-align">
								<li>Easy to understand.</li>
								<li>Easy to maintain.</li>
								<li>Easy to test.</li>
							</ul>
						</div>
						<img class="r-stretch" alt="Brain Natural vs Math" width="400px" src="./dist/theme/img/math-brain.webp"/>
					</div>
				</section>


				<section data-background-image="./dist/theme/img/background.png"  data-auto-animate="box">
					<h2>What Defines Functional Programming?</h2>
					<h3>Core Principles</h3>
					<ol>
						<li class="fragment">Pure Functions<p class="footnote-text">Functions with predictable outputs and no side effects.</p></li>
						<li class="fragment">Immutability<p class="footnote-text">Data cannot be modified after creation.</p></li>
						<li class="fragment">First-Class and Higher-Order Functions<p class="footnote-text">Functions treated as first-class citizens, can be passed and returned.</p></li>
						<li class="fragment">Composability<p class="footnote-text">Functions are composable, allowing small, simple functions to combine into complex functionality.</p></li>
						<li class="fragment">Closures<p class="footnote-text">A closure is a function that captures its scope, allowing access to variables after the scope exits.</p></li>
						<li class="fragment">Recursion over Loops<p class="footnote-text">Solving problems through recursive function calls instead of iterative loops.</p></li>
						<li class="fragment">Referential Transparency<p class="footnote-text">Expressions can be replaced with their values without changing program behavior.</p></li>
						<li class="fragment">Pattern Matching<p class="footnote-text">Powerful way to deconstruct and match data structures.</p></li>
						<li class="fragment">Generics and Parametric Polymorphism<p class="footnote-text">Writing flexible, reusable code that works with multiple types.</p></li>
						<li class="fragment">Algebraic Data Types (ADTs)<p class="footnote-text">Composing complex types from simpler ones.</p></li>
					</ol>
					<aside class="notes">
						Pattern Matching:<br/>
						more then equal.
						where to check if a has the brand name Mercedes<br/>
						it is more like checking if this car is a Mercedes with a Diesel engine with 400 hourse powers.
						<br/>
						<br/>
						and here is the Algebra.<br/>
						but i said we don't want to talk about math..<br/>
						so lets skip..
  					</aside>
				</section>


				<section data-background-image="./dist/theme/img/background.png"  >
					<section data-background-image="./dist/theme/img/background.png"  data-auto-animate="box">
						<h2>Which Principles are not directly in Go?</h2>
						<ol>
							<li>Immutability<p class="footnote-text">Data cannot be modified after creation.</p></li>
							<li>Recursion over Loops<p class="footnote-text">Solving problems through recursive function calls instead of iterative loops.</p></li>
							<li>Referential Transparency<p class="footnote-text">Expressions can be replaced with their values without changing program behavior.</p></li>
							<li>Pattern Matching<p class="footnote-text">Powerful way to deconstruct and match data structures.</p></li>
							<li>Algebraic Data Types (ADTs)<p class="footnote-text">Composing complex types from simpler ones.</p></li>
						</ol>
						<aside class="notes">
							o 50% is still in, which could be worth exploring
							But good thing, the worst things are out
	  					</aside>
					</section>


					<section data-background-image="./dist/theme/img/background.png" >
						<h2>Immutability</h2>
						<div class="two-col centered">
							<div ><strong>Definition:</strong> Data doesn't change after it's created.</div>
							<div><strong>Benefit:</strong> Ensures thread safety and avoids side effects.</div>
						</div>
						<div class="two-col">
							<div>
								<pre>Haskell<code class="language-haskell" data-trim data-noescape>
									let x = 5
									let y = x + 3 -- x remains unchanged
								</code></pre>
							</div>
							<div>
								<pre>Go<code class="language-go" data-trim data-noescape>
									x := 5
									x = x + 3 // x is modified
								</code></pre>
							</div>
						</div>
					</section>


					<section data-background-image="./dist/theme/img/background.png" >
						<h2>Referential Transparency</h2>
						<p class="centered"><strong>Definition:</strong> Same input, same output.<br>
							<strong>Benefit:</strong> Easier reasoning and testing.</p>
						<div class="two-col">
							<div>
								<pre>Haskell<code class="language-haskell" data-trim data-noescape>
									square x = x * x
									square 5 -- Always evaluates to 25
								</code></pre>
							</div>
							<div>
								<pre>Go<code class="language-go" data-trim data-noescape>
									func square(x int) int {
										fmt.Println("Squaring", x) // Side effect
										return x * x
									}
								</code></pre>
							</div>
						</div>
					</section>


					<section data-background-image="./dist/theme/img/background.png" >
						<h2>Pattern Matching</h2>
						<p><strong>Definition:</strong> Simplifies control flow by destructuring and analyzing data.</p>
						<div class="two-col">
							<div>
								<pre>Haskell<code class="language-haskell" data-trim data-noescape>
									data Shape = Circle Float | Rectangle Float Float

									area :: Shape -> Float
									area (Circle r) = pi * r * r
									area (Rectangle w h) = w * h
								</code></pre>
							</div>
							<div>
								<pre>Go<code class="language-go" data-trim data-noescape data-line-numbers="|1,5">
									type Shape interface{}
									type Circle struct { Radius float64 }
									type Rectangle struct { Width, Height float64 }

									func area(s Shape) float64 {
										switch shape := s.(type) {
											case Circle:
												return math.Pi * shape.Radius * shape.Radius
											case Rectangle:
												return shape.Width * shape.Height
											default:
												return 0
										}
									}
								</code></pre>
							</div>
						</div>
						<p>Everthing could be added here, no pattern matching, better use inteface with defined Area() function</p>
					</section>


					<section data-background-image="./dist/theme/img/background.png" >
						<h2>Algebraic Data Types (ADTs)</h2>
						<p><strong>Definition:</strong> Structuring data concisely using sum and product types.</p>
						<div class="two-col">
							<div>
								<pre>Haskell<code class="language-haskell">data Result = Success String | Failure String</code></pre>
							</div>
							<div>
								<pre>Go<code class="language-go" data-trim data-noescape>
									type Result struct {
										Success bool
										Message string
									}
								</code></pre>
							</div>
						</div>
					</section>
				</section>


				<section data-background-image="./dist/theme/img/background.png"  data-auto-animate>
					<h2>What Functional Principles are Available?</h2>
					<ol>
						<li>Pure Functions<p class="footnote-text">with manual effort to avoid side effects.</p></li>
						<li>Composability<p class="footnote-text">manual composition.</p></li>
						<li>First-Class and Higher-Order Functions<p class="footnote-text">fully covered.</p></li>
						<li>Closures<p class="footnote-text">fully covered.</p></li>
						<li>Generics and Parametric Polymorphism<p class="footnote-text">introduced in Go 1.18+, excluding methods.</p></li>
					</ol>
					<aside class="notes">
						lets see what this is about and how it works in go
  					</aside>
				</section>


				<section data-background-image="./dist/theme/img/background.png" >
					<h2>From Principles to Practice: Building Blocks</h2>
  					<br/>
  					<p class="left-align"><h3 class="left-align">Pure Functions</h3>Functions that always return the same output for the same input and produce no side effects.</p>
  					<pre><code class="language-go" data-line-numbers="1|3-10|12-18" data-trim data-noescape>
						  f(x) â†’ y   // Always same output for same input

						  func square(x int) int {   // A pure function in Go. It is deterministic and satisfies referential transparency.
						      return x * x
						  }

						  // For any x:
						  square(4)  // Always returns 16
						  square(4)  // Always returns 16
						  square(4)  // Always returns 16

						  // But real world has side effects:
						  // - File operations might fail
						  // - Network calls can timeout
						  // - Values might be missing
						  // - Operations can fail
						              â†“
						  function wrapValue(x) â†’ box(x)   // What if we could extend this?
					  </code></pre>
					  <aside class="notes">
						We've seen how pure functions transform values in predictable ways.
  						But in real applications, we often need to add context to these transformations
  						- like handling errors,<br/>
  						dealing with optional values,<br/>
  						or managing side effects.<br/>
						  <br/>
						  <br/>
  						What if we could wrap our values in a way<br/>
  						that adds this extra context while preserving our ability to chain operations?
						  <br/>
						  <br/>
						that sounds to simple, yes, real worl is mostly more complex<br/>
						<br/>
						there are side effects<br/>
						 and many reasons why our function could fail<br/>
						 <br/>
						 So what if would would change our function, to instead of return a simple value
						 return a box that contains this value, and the box covers those side effects?
					  </aside>
				</section>


				<section data-background-image="./dist/theme/img/background.png" >
					<h2>Patterns for Composition</h2>
					<br/>
					<pre>Values with a context<code data-trim data-noescape>
						Simple Value:     42
						With Context:     Result[42]  // Success(42) or Error("failed")
						                  Optional[42] // Some(42) or None()
					</code></pre>

					<pre class="fragment">In Go:<code data-trim data-noescape>
						type Result[T any] struct {
						    value T
						    err   error
						}

						// These containers let us:
						func Transform[T, U any](r Result[T], f func(T) U) Result[U]
						func Chain[T, U any](r Result[T], f func(T) Result[U]) Result[U]
					</code></pre>
					<p class="fragment left-align">These containers are called <strong>Monads</strong>.</p>
					<aside class="notes">
						Just as pure functions help us reason about transformations,
						these special containers help us reason about common patterns in our code.
						A monad is simply a container that follows specific rules about how values can be wrapped and transformed.
					</aside>
					<aside class="notes">
						so instead of a single value, lets add a context that gives a description of what happend<br/>
						<br/>
						like a Result. A result of a function, can be either success or there was an error
						or an Optional result, because sometimes we have a result, but no all the time.
						<br/>
						<br/>
						If we create those boxes in go, that is how they could look like<br/>
						<br/>
						So define a struct our box, and store a value and an error inside<br/>
						<br/>
						Once we have such a box, we could add some methods, for example to transform our value or to chain it.<br/>
						<br/>
						In FP those boxes are colled Monads
  					</aside>
				</section>


				<section data-background-image="./dist/theme/img/background.png" >
					<h2>What is a Monad?</h2>
					<br/>
					<p>Think of it as a container that follows <i>three</i> simple rules:</p>
					<ol>
						<li class="fragment">It can <i>wrap any value</i> (like putting a gift in a box).</li>
						<li class="fragment">You can <i>transform</i> the value (while it stays in the box).</li>
						<li class="fragment">You can <i>chain</i> operations (passing the boxed value along).</li>
					</ol>
					<p class="fragment">See? Monads aren't scary - they're just smart boxes!</p>
				</section>


				<section data-background-image="./dist/theme/img/background.png" >
					<h2>Practical Example</h2>
					<br/>
					<h3>Error Handling</h3>
					<pre>This is how a typical function call looks like in Go:<code data-trim data-noescape>
						value, err := doSomething()
						if err != nil {
						    return err
						}
						// use value
					</code></pre>
				</section>


				<section data-background-image="./dist/theme/img/background.png" >
					<h2>Let's Check Out the Code</h2>
					<div>
						<br/>
						<a href="https://github.com/fmt-Println-MKO/fp_kata/tree/8ffcdcbba417e875aec777b43969f17b0e213e04/internal" target="_blank">â†’ Project Code</a>
						<br/>
					</div>
					<br/>
					<ul>
						<li>Typical code structure.</li>
						<li>3-layered architecture - data layer, business layer, API layer.</li>
						<li>It simulates an app that can register users, and users can place an order with associated payments.</li>
						<li>It contains logging and authentication middleware and simulates an authorization service.</li>
						<li>Full unit test coverage.</li>
						<li><a href="https://github.com/fmt-Println-MKO/fp_kata/blob/8ffcdcbba417e875aec777b43969f17b0e213e04/FP-Kata.http" target="_blank">GoLand/IntelliJ</a> API calls available.</li>
					</ul>
					<br/>
					<p><br/><a href="#/18">Continue Presentation</a></p>
				</section>


				<section data-background-image="./dist/theme/img/background.png" >
					<h2>Let's Look at the Order Data Layer</h2>
					<div>
						<a href="https://github.com/fmt-Println-MKO/fp_kata/blob/8ffcdcbba417e875aec777b43969f17b0e213e04/internal/datasources/file/orders_mem_storage.go" target="_blank">orders_mem_storage.go</a>
					</div>
					<ul>
						<li>Simple in-memory storage for orders.</li>
						<li>Classic Go layout with returning value and errors.</li>
					</ul>
				</section>


				<section data-background-image="./dist/theme/img/background.png" >
					<h2>Let's Look at the Order Data Layer Unit Test</h2>
					<div>
						<a href="https://github.com/fmt-Println-MKO/fp_kata/blob/8ffcdcbba417e875aec777b43969f17b0e213e04/internal/datasources/file/orders_mem_storage_test.go" target="_blank">orders_mem_storage_test.go</a>
					</div>
					<ul>
						<li>Unit tests avoid any conditional logic inside the runner.</li>
						<li>To make clear what is expected from each test, a validate function needs to be added.</li>
						<li>That moves all the assertions into the test description and out of the runner.</li>
						<li>Not ideal, but better compared to having conditions within the runner as it forces every new test case to think about the expected result.</li>
					</ul>
				</section>


				<section data-background-image="./dist/theme/img/background.png" >
					<h2>How Monads Could Solve It</h2>
					<p>Switch to the Step 1 branch for the monads.</p>
					<p>Let's create our own Result monad.</p>
					<div>
						<a href="https://github.com/fmt-Println-MKO/fp_kata/blob/692328122ffc480830941fb54981dedc3f80d5f1/common/monads/result.go" target="_blank">result.go</a>
					</div>
					<p>What is this Monad about?</p>
					<ul>
						<li>It is a container for anything.</li>
						<li>It encapsulates either a result value or an error and knows if it has a valid result or not.</li>
						<li>It can be easily created with the OK or the Err (Errf) function.</li>
						<li>It provides methods to provide information about the context: IsOk(), IsError().</li>
						<li>It provides methods to retrieve its value: MustGet() and Error().</li>
					</ul>
				</section>


				<section data-background-image="./dist/theme/img/background.png" >
					<h2>Let's Use this Monad in our Order Storage</h2>
					<div>
						<a href="https://github.com/fmt-Println-MKO/fp_kata/blob/692328122ffc480830941fb54981dedc3f80d5f1/internal/datasources/file/orders_mem_storage.go" target="_blank">orders_mem_storage.go</a>
					</div>
					<p>What has changed?</p>
					<ul>
						<li>We only return a single value now, our Result Monad instead of two before (order and error).</li>
						<li>We use the helper functions to construct the Monad.</li>
						<li>Ok() for the positive case.</li>
						<li>Errf() for the negative case.</li>
					</ul>
					<p>Not a big change yet?</p>
				</section>


				<section data-background-image="./dist/theme/img/background.png" >
					<h2>Let's See How This Affected Our Unit Tests</h2>
					<div>
						<a href="https://github.com/fmt-Println-MKO/fp_kata/blob/692328122ffc480830941fb54981dedc3f80d5f1/internal/datasources/file/orders_mem_storage_test.go" target="_blank">orders_mem_storage_test.go</a>
					</div>
					<p>What has changed here?</p>
					<ul>
						<li>No more helper functions.</li>
						<li>No more validate functions in the test description.</li>
						<li>All assertions are now in the runner itself.</li>
						<li>No conditional logic inside the runner.</li>
						<li>A single assert covers it all.</li>
					</ul>
					<p>You think about results in your test description and no more about validations and assertions.</p>
					<p>Isn't that simpler and easier?</p>
					<aside class="nodes">
						Link to why we don't want conditions inside the test runner
						https://speakerdeck.com/gaqzi/how-to-design-a-test-suite-youll-love-to-maintain
					</aside>
				</section>


				<section data-background-image="./dist/theme/img/background.png" >
					<h2>How Does This Change Affect the Service Layer?</h2>
					<div>
						<a href="https://github.com/fmt-Println-MKO/fp_kata/blob/692328122ffc480830941fb54981dedc3f80d5f1/internal/services/orders_service.go" target="_blank">orders_service.go</a>
					</div>
					<p>What has changed here?</p>
					<ul>
						<li>We only receive the Result Monad.</li>
						<li>So clients of order storage can no longer ignore a possible error.</li>
						<li>We use a method now (not an expression) to ask the Result Monad about its context if there was an error.</li>
					</ul>
					<p>Asking the monad about its result context is more natural language.</p>
					<p>Isn't that simpler and easier?</p>
				</section>


				<section data-background-image="./dist/theme/img/background.png" >
					<h2>What Have We Achieved? (1/2)</h2>
					<pre>
						<code data-trim data-noescape data-line-numbers="1-2|3-5">
							// multiple return values
							GetOrder(ctx context.Context, orderID int) (*dsmodels.Order, error)
							                             â†“
							// return single box/container --> Monad
							GetOrder(ctx context.Context, orderID int) monads.Result[dsmodels.Order]
						</code>
					</pre>
					<p class="fragment">Only return a single entity</p>
					<pre class="fragment"><code data-trim data-noescape data-line-numbers="1-12|13-15">
						validateOrderMatches := func(t *testing.T, expected, actual *dsmodels.Order, err error) {
							assert.NoError(t, err, "unexpected error received")
							assert.Equal(t, expected, actual, "expected order mismatch")
						}
						validateOrderNotFound := func(t *testing.T, actual *dsmodels.Order, err error) {
							assert.Nil(t, actual, "expected no order to be returned")
							assert.EqualError(t, err, errOrderNotFound, "expected error mismatch")
						}

						validate: func(t *testing.T, order *dsmodels.Order, err error) {
							validateOrderMatches(t, &dsmodels.Order{ID: 1, UserID: 123, Payments: []int{1, 2}}, order, err)
						},
														â†“
						//it makes our unit tests much simpler
						expectedResult: monads.Ok(dsmodels.Order{ID: 1, UserID: 123, Payments: []int{1, 2}}),
					</code></pre>
					<p class="fragment">It makes our unit tests much simpler.</p>
					<aside class="nodes">
						Link to why we don't want conditions inside the test runner
						https://speakerdeck.com/gaqzi/how-to-design-a-test-suite-youll-love-to-maintain
					</aside>
				</section>


				<section data-background-image="./dist/theme/img/background.png" >
					<h2>What Have We Achieved? (2/2)</h2>
					<pre><code data-trim data-noescape data-line-numbers="1-2|3-4">
						//dsOrder, _ := service.storage.GetOrder(ctx, id)
						dsOrder, err := service.storage.GetOrder(ctx, id)
												â†“
						dsOrderResult := service.storage.GetOrder(ctx, id)
					</code></pre>
					<p class="fragment">Clients can no longer ignore errors.</p>
					<pre class="fragment"><code data-trim data-noescape data-line-numbers="1|2-3">
						if err != nil
								â†“
						if dsOrderResult.IsError()
					</code></pre>
					<p class="fragment">Using a speaking method is closer to natural language for understanding what the code is about.</p>
					<h3 class="fragment">Let's Go to Step 2 and Talk About Chaining</h3>
					<br/>
					<p><br/><a href="#/26">Continue Presentation</a></p>
				</section>


				<section data-background-image="./dist/theme/img/background.png">
				    <h2>Some Improvements Before We Go Further</h2>
				    <div>
				        <a href="https://github.com/fmt-Println-MKO/fp_kata/blob/Step-2-Function-Chain/internal/datasources/file/orders_mem_storage.go" target="_blank">orders_mem_storage.go</a>
				    </div>
				    <p>What has changed here?</p>
				    <ul>
				        <li>Using a monad library instead of our own result Monad: github.com/samber/mo.</li>
				        <li>That library features many Monads with all instructions needed to make them powerful.</li>
				    </ul>
				</section>
				<section data-background-image="./dist/theme/img/background.png">
				    <h2>Let's Check How We Currently Process the Order</h2>
				    <p>How do we convert the result from the storage layer and transform and enrich it to the required result of the service?</p>
				    <div>
				        <a href="https://github.com/fmt-Println-MKO/fp_kata/blob/692328122ffc480830941fb54981dedc3f80d5f1/internal/services/orders_service.go#L173" target="_blank">orders_service.go processOrder</a>
				    </div>
				    <p>What do we have here?</p>
				    <ul>
				        <li>We have 5 return statements within a single function.</li>
				        <li>We call the authorization service.</li>
				        <li>We process the result from the authorization service.</li>
				        <li>We add the payment info from a separate function.</li>
				        <li>We add the user info from a separate function.</li>
				        <li>For every step, there is an expression to check if we can continue or not.</li>
				    </ul>
				    <p>Wouldn't it be better if we had just a single return statement and a single check?</p>
				</section>
				<section data-background-image="./dist/theme/img/background.png">
				    <h2>Could Monads Help Solve Our Previous Question?</h2>
				    <p>What did we say about a Monad: it's a value with context.</p>
				    <p>Let's use this knowledge about context.</p>
				    <div>
				        <a href="https://github.com/samber/mo?tab=readme-ov-file#resultt-any" target="_blank">Result Monad Documentation</a>
				    </div>
				    <p>What do we have here?</p>
				    <ul>
				        <li>Some more methods that deal with the context compared to what we created in the first step.</li>
				        <li>Let's look at Flatmap: <a href="https://pkg.go.dev/github.com/samber/mo#Result.FlatMap" target="_blank">FlatMap Documentation</a></li>
				        <li>It is a mapper if we have a valid result.</li>
				        <li>It uses the knowledge of the context to safely execute a mapping function if there is a valid result.</li>
				        <li>The mapper function itself should also return a ResultMonad, and FlatMap returns a Result Monad.</li>
				        <li>Let's check the example: <a href="https://go.dev/play/p/Ud5QjZOqg-7" target="_blank">FlatMap Playground</a></li>
				    </ul>
				    <p>So what do we need to make use of it?</p>
				</section>
				<section data-background-image="./dist/theme/img/background.png">
				    <h2>We Need More Monads</h2>
				    <p>Let's change the functions to return Monads.</p>
				    <div>
				        <a href="https://github.com/fmt-Println-MKO/fp_kata/blob/773a924b0729e50a5454dae12fdd82682b73340a/internal/services/orders_service.go#L205" target="_blank">orders_service.go addUser</a>
				    </div>
				    <p>What do we have here?</p>
				    <ul>
				        <li>We moved the authorization check into a function that returns a Monad.</li>
				        <li>The addPayment method now returns a Monad.</li>
				        <li>The addUser method now returns a Monad.</li>
				    </ul>
				    <p>How do we make use of these?</p>
				</section>
				<section data-background-image="./dist/theme/img/background.png">
				    <h2>Now That We Have Monads, Let's Chain Them</h2>
				    <p>We now have 4 functions that all return a Result Monad.</p>
				    <div>
				        <a href="https://github.com/fmt-Println-MKO/fp_kata/blob/773a924b0729e50a5454dae12fdd82682b73340a/internal/services/orders_service.go#L168" target="_blank">orders_service.go processOrder</a>
				    </div>
				    <p>What happened here?</p>
				    <ul>
				        <li>Because the Monad knows its context (was there an error or a valid result).</li>
				        <li>FlatMap executes the passed function based on the context.</li>
				        <li>Calling FlatMap preserves the context.</li>
				        <li>We can chain the calls to FlatMap safely.</li>
				        <li>In case of an error, we preserve it and return a safe result.</li>
				    </ul>
				</section>
				<section data-background-image="./dist/theme/img/background.png">
				    <h2>Summary</h2>
				    <p>What happened here?</p>
				    <ul>
				        <li>We composed small functions into more complex ones.</li>
				        <li>We chained the function calls.</li>
				        <li>We only need to check for a result in a single place.</li>
				        <li>We only have a single return statement.</li>
				        <li>In case of an error, we preserve it and return a safe result.</li>
				    </ul>
				</section>
				<section data-background-image="./dist/theme/img/background.png">
				    <h2>What Did We Achieve in Step 2? (Part 1)</h2>
				    <div class="columns">
				        <div class="column">
				            <pre>
				                <code class="language-go" data-trim data-noescape>
				                    // Authorization check
				                    isAuthorized, err := service.authorizationService.IsAuthorized(ctx, userId, order)
				                    if err != nil {
				                        return nil, err
				                    }
				                    if !isAuthorized {
				                        return nil, errors.New("user is not authorized to access this order")
				                    }
				                    // Add payments to the order
				                    order, err = service.addPayments(ctx, order)
				                    if err != nil {
				                        return nil, err
				                    }
				                    // Add user to the order
				                    order, err = service.addUser(ctx, order)
				                    if err != nil {
				                        return nil, err
				                    }
				                    return order, nil
				                </code>
				            </pre>
				        </div>
				        <div class="column">
				            <pre>
				                <code class="language-go" data-trim data-noescape>
				                    // Authorization check
				                    return service.verifyAuthorization(ctx, userId, order).
				                        // Add payments to the order
				                        FlatMap(func(value *models.Order) mo.Result[*models.Order] {
				                            return service.addPayments(ctx, value)
				                        }).
				                        // Add user to the order
				                        FlatMap(func(value *models.Order) mo.Result[*models.Order] {
				                            return service.addUser(ctx, value)
				                        })
				                </code>
				            </pre>
				            <div class="fragment">
				                <ul>
				                    <li>Using the benefit of Monads that know their context.</li>
				                    <li>We composed small functions into a more complex one.</li>
				                </ul>
				            </div>
				            <br/>
				            <ul>
				                <li class="fragment">The code is more concise.</li>
				                <li class="fragment">There is only a single return statement.</li>
				                <li class="fragment">The code is easier to understand.</li>
				                <li class="fragment">Don't read it like a book.</li>
				            </ul>
				        </div>
				    </div>
				    <p class="fragment">Not readable like a book?</p>
				</section>
				<section data-background-image="./dist/theme/img/background.png">
				    <h2>What Did We Achieve in Step 2? (Part 2)</h2>
				    <div>
				        <p>Imagine it like this:</p>
				    </div>
				    <div class="columns">
				        <div class="column">
				            <pre>
				                <code class="language-go" data-trim data-noescape>
				                    // Authorization check
				                    return service.verifyAuthorization(ctx, userId, order).
				                        // Add payments to the order
				                        FlatMap(func(value *models.Order) mo.Result[*models.Order] {
				                            return service.addPayments(ctx, value)
				                        }).
				                        // Add user to the order
				                        FlatMap(func(value *models.Order) mo.Result[*models.Order] {
				                            return service.addUser(ctx, value)
				                        })
				                </code>
				            </pre>
				        </div>
				        <div class="column">
				            <pre>
				                <code class="language-go" data-trim data-noescape>
				                    // Authorization check
				                    return service.verifyAuthorization(userId, order).
				                        // Add payments to the order
				                        FlatMap(service.addPayments).
				                        // Add user to the order
				                        FlatMap(service.addUser)
				                </code>
				            </pre>
				        </div>
				    </div>
				    <p>Better now?</p>
				    <p class="fragment">But that's another story about how to remove the Context. ;)</p>
				</section>


				<section data-background-image="./dist/theme/img/background.png" >
					<h2>Summary of Part 1</h2>
					<img class="r-stretch" alt="Functional Chain" src="./dist/theme/img/functional-chain.webp"/>
					<ul class="left-align">
					    <li>We implemented the Result Monad pattern to manage computational context and error handling.</li>
					    <li>Using Monads allowed us to separate our core business logic from error handling concerns.</li>
					    <li>We leveraged <b>Higher Order Functions</b> and <b>Function Composition</b> to build complex operations from simple, <b>Pure Functions</b>.</li>
					    <li>The FlatMap operation enabled us to chain operations while safely handling potential failures.</li>
					    <li>We transformed imperative error-checking code into a declarative function pipeline.</li>
					</ul>
					<p class="left-align">This approach provided:</p>
					<ul class="left-align">
					    <li>Better separation of concerns between business logic and error handling.</li>
					    <li>More declarative and composable code structure.</li>
					    <li>Predictable function behavior, making testing more straightforward.</li>
					    <li>Improved maintainability through functional composition.</li>
					</ul>
					<p> </p>
					<h4>Code that is easier to read, test and maintain.</h4>

				</section>


				<section data-background-image="./dist/theme/img/main.webp">
					<h2 style="color: #f8f9fb; margin-top: 120px">Thank you for your attention.<br/>May your functions be pure, your chains unbroken, and your code as timeless as the wisdom of the masters.</h2>
					<img class="r-stretch" alt="Functional Kata Gopher" src="./dist/theme/img/fp_kata_gopher.png"/>
					<div class="left-align" style="color: #f8f9fb; padding-left: 4px; background-color:rgba(0, 0, 0, 0.5);">Matthias Koch | <span class="footnote-text">Delivery Hero</span></div>
					<div class="footnote-text left-align" style="color: #f8f9fb; padding-left: 4px; background-color:rgba(0, 0, 0, 0.5);">functional style since 2013 - Skala Java Kotlin Haskell-(EM) <b style="font-weight:bold; font-size: 1.6em; color: #f8f9fb; ">Go</b> Dart</div>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script src="plugin/math/math.js"></script>
		<script>
			Reveal.initialize({
				hash: true,
				slideNumber: "c/t",
				disableLayout: false,
				width: 1100,

				controls: true,
				progress: true,
				mouseWheel: false,
				showNotes: false,
				fragmentInURL: true,
				autoSlide: 0,
				autoSlideStoppable: true,
				scrollActivationWidth: null,
				shuffle: false,
				loop: false,
				rtl: false,
				navigationMode: "default",
				transition: "fade",
				backgroundTransition: "zoom",
				highlight: {
					escapeHTML: false
				},
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.KaTeX]
			});
		</script>
	</body>
</html>
